# -*- coding: utf-8 -*-
"""
Created on Tue Jan 13 16:22:50 2026

@author: navar
"""

# -*- coding: utf-8 -*-
"""
SCRIPT 2: ICA y Epoching INDIVIDUAL (Run por Run)
-------------------------------------------------
1. Busca los archivos _prepro_raw.fif (salida del Script 1).
2. Calcula ICA individualmente (te pedirá seleccionar componentes).
3. Aplica Gating de ECG (si existe canal ECG).
4. Corta épocas y permite rechazo manual visual.
5. Guarda un archivo _epo.fif por cada run.
"""

import mne
import numpy as np
import re
from pathlib import Path

# =============================================================================
# 1. CONFIGURACIÓN
# =============================================================================
BASE_PATH = Path(r"C:\Users\navar\Desktop\sub-P01\sub-P01")

# Buscamos los archivos generados en el Script 1
# Patrón: cualquier cosa que termine en _prepro_raw.fif
INPUT_FILES = sorted(list(BASE_PATH.glob("*_prepro_raw.fif")))

# Escalas para visualización
VIZ_SCALINGS = dict(eeg=50e-6, eog=150e-6, misc=50e-6)

# Canales EEG para el ICA (Solo cabeza)
EEG_CHS = [
    'Fp1', 'Fz', 'F3', 'F7', 'FT9', 'FC5', 'FC1', 'C3', 'T7', 'TP9', 'CP5', 'CP1', 
    'Pz', 'P3', 'P7', 'O1', 'Oz', 'O2', 'P4', 'P8', 'TP10', 'CP6', 'CP2', 'C4', 
    'T8', 'FT10', 'FC6', 'FC2', 'F4', 'F8', 'Fp2', 'AF7', 'AF3', 'AFz', 'F1', 
    'F5', 'FT7', 'FC3', 'C1', 'C5', 'TP7', 'CP3', 'P1', 'P5', 'PO7', 'PO3', 
    'POz', 'PO4', 'PO8', 'P6', 'P2', 'CPz', 'CP4', 'TP8', 'C6', 'C2', 'FC4', 
    'FT8', 'F6', 'AF8', 'AF4', 'F2'
]

# Códigos de Eventos (Standard vs Deviant)
TARGET_CODES = {
    # Left
    18: 111, 19: 112, 20: 113, 21: 114, 22: 115, 23: 116, 25: 121,
    # Right
    34: 211, 35: 212, 36: 213, 37: 214, 38: 215, 39: 216, 41: 221
}

# =============================================================================
# 2. BUCLE PRINCIPAL (Itera sobre cada Run)
# =============================================================================
print(f"Archivos encontrados para procesar: {len(INPUT_FILES)}")

for i, f_path in enumerate(INPUT_FILES):
    print(f"\n========================================")
    print(f"PROCESANDO RUN {i+1}/{len(INPUT_FILES)}: {f_path.name}")
    print(f"========================================")

    # 1. CARGA
    raw = mne.io.read_raw_fif(f_path, preload=True)
    
    # 2. ICA (Optimizado 1Hz)
    print("--- ICA (Interactive) ---")
    print("Generando copia filtrada a 1Hz para detección óptima...")
    raw_for_ica = raw.copy().filter(l_freq=1.0, h_freq=None, n_jobs=1, verbose=False, picks=EEG_CHS)
    
    ica = mne.preprocessing.ICA(n_components=20, random_state=97)
    ica.fit(raw_for_ica, picks=EEG_CHS, decim=10)
    
    print(">> SE ABRE VENTANA ICA: Marca en ROJO el parpadeo (ICA000) y el corazón (ICA001).")
    print(">> Cierra la ventana cuando termines para continuar.")
    
    # block=True detiene el script hasta que cierres la ventana
    ica.plot_sources(raw_for_ica, block=True, title=f"ICA Run {i+1}: Marca Ojos/Corazón")
    
    print("Aplicando limpieza ICA a los datos originales...")
    raw = ica.apply(raw)
    del raw_for_ica # Limpieza de RAM

    # 3. EVENTOS
    print("--- Eventos ---")
    events_raw, event_id_found = mne.events_from_annotations(raw, verbose=False)
    
    # Mapeo robusto de descripciones a números
    my_map = {}
    for description in event_id_found.keys():
        numbers = re.findall(r'\d+', description)
        if numbers:
            code_in_file = int(numbers[-1])
            if code_in_file in TARGET_CODES:
                my_map[description] = TARGET_CODES[code_in_file]
    
    if not my_map:
        print("¡ALERTA! No se encontraron eventos compatibles en este run. Saltando...")
        continue

    events, _ = mne.events_from_annotations(raw, event_id=my_map)

    # 4. GATING ECG (Opcional pero recomendado)
    if 'ECG' in raw.ch_names:
        print("--- Gating ECG ---")
        try:
            # Detectar latidos
            ecg_events = mne.preprocessing.find_ecg_events(raw, ch_name='ECG', verbose=False)[0]
            
            # Crear zona prohibida (+/- 150ms alrededor del latido)
            sr = raw.info['sfreq']
            win_samps = int(0.150 * sr)
            bad_samples = set()
            for r_peak in ecg_events[:, 0]:
                bad_samples.update(range(r_peak - win_samps, r_peak + win_samps))
            
            # Filtrar eventos que caen en latido
            n_orig = len(events)
            events = np.array([ev for ev in events if ev[0] not in bad_samples])
            print(f"Eventos eliminados por coincidir con latido: {n_orig - len(events)}")
        except Exception as e:
            print(f"Error en Gating ECG (no crítico): {e}")

    # 5. EPOCHING
    print("--- Creando Épocas ---")
    epochs = mne.Epochs(
        raw, events, event_id=None, 
        tmin=-0.1, tmax=0.65, 
        baseline=(-0.1, 0), 
        preload=True, 
        reject=None, 
        reject_by_annotation=False,
        verbose=False
    )
    
    # 6. RECHAZO MANUAL
    print(">> SE ABRE VENTANA ÉPOCAS: Revisa y marca las ruidosas.")
    print(">> Cierra la ventana para guardar y pasar al siguiente run.")
    epochs.plot(block=True, n_epochs=4, n_channels=30, scalings=VIZ_SCALINGS, title=f"Run {i+1}: Rechazo Manual")

    # 7. GUARDAR
    # Generamos nombre: sub-P01_run01_epo.fif
    # Usamos f_path.stem que es "sub-P01_run01_prepro_raw" y le quitamos "_prepro_raw" si queremos, o simplemente añadimos "_epo"
    # Opción limpia: reemplazar "_prepro_raw" por "_epo"
    out_name = f_path.name.replace("_prepro_raw.fif", "_epo.fif")
    out_path = BASE_PATH / out_name
    
    print(f"Guardando: {out_name}")
    epochs.save(out_path, overwrite=True)
    
    # Liberar memoria
    del raw, epochs, ica

print("\n¡PROCESO COMPLETADO! Todos los runs han sido limpiados y guardados.")
