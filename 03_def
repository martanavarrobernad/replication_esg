# -*- coding: utf-8 -*-
"""
Created on Wed Jan 14 11:37:30 2026

@author: navar
"""

# -*- coding: utf-8 -*-
"""
SCRIPT 2 MAESTRO: Limpieza Manual -> ICA -> Interpolación Final
---------------------------------------------------------------
1. Inspección visual: Marcas canales malos y tramos ruidosos.
2. FIX AUTOMÁTICO: Resetea la referencia para evitar el error (60 vs 62).
3. ICA: Calcula componentes ignorando lo malo.
4. Epoching: Corta y limpia.
5. INTERPOLACIÓN FINAL: Reconstruye los canales malos antes de guardar 
   para que la concatenación (Script 3) sea perfecta.
"""

import mne
import numpy as np
import re
from pathlib import Path

# =============================================================================
# 1. CONFIGURACIÓN
# =============================================================================
BASE_PATH = Path(r"C:\Users\navar\Desktop\sub-P01\sub-P01")
INPUT_FILES = sorted(list(BASE_PATH.glob("*_prepro_raw.fif")))

# Escalas visuales (Ajustadas para ver bien)
VIZ_SCALINGS = dict(eeg=50e-6, eog=150e-6, misc=50e-6)

# Canales EEG para el ICA
EEG_CHS = [
    'Fp1', 'Fz', 'F3', 'F7', 'FT9', 'FC5', 'FC1', 'C3', 'T7', 'TP9', 'CP5', 'CP1', 
    'Pz', 'P3', 'P7', 'O1', 'Oz', 'O2', 'P4', 'P8', 'TP10', 'CP6', 'CP2', 'C4', 
    'T8', 'FT10', 'FC6', 'FC2', 'F4', 'F8', 'Fp2', 'AF7', 'AF3', 'AFz', 'F1', 
    'F5', 'FT7', 'FC3', 'C1', 'C5', 'TP7', 'CP3', 'P1', 'P5', 'PO7', 'PO3', 
    'POz', 'PO4', 'PO8', 'P6', 'P2', 'CPz', 'CP4', 'TP8', 'C6', 'C2', 'FC4', 
    'FT8', 'F6', 'AF8', 'AF4', 'F2'
]

TARGET_CODES = {
    18: 111, 19: 112, 20: 113, 21: 114, 22: 115, 23: 116, 25: 121, # Left
    34: 211, 35: 212, 36: 213, 37: 214, 38: 215, 39: 216, 41: 221  # Right
}

# =============================================================================
# 2. BUCLE DE PROCESAMIENTO
# =============================================================================
print(f"Archivos encontrados: {len(INPUT_FILES)}")

for i, f_path in enumerate(INPUT_FILES):
    print(f"\n========================================")
    print(f"PROCESANDO RUN {i+1}/{len(INPUT_FILES)}: {f_path.name}")
    print(f"========================================")

    # 1. CARGA
    raw = mne.io.read_raw_fif(f_path, preload=True)
    
    # 2. INSPECCIÓN VISUAL (Tú mandas aquí)
    print("\n>>> PASO A: INSPECCIÓN VISUAL <<<")
    print(" - Haz CLIC en los nombres de canales rotos para marcarlos como 'BAD'.")
    print(" - Pulsa 'a' para marcar tramos de ruido (BAD_...) con el ratón.")
    
    raw.plot(block=True, n_channels=30, scalings=VIZ_SCALINGS, 
             title=f"RUN {i+1}: Marca Canales Malos y Segmentos")
    
    # 3. FIX DE GEOMETRÍA (La solución a tu error 60 vs 62)
    # Si has marcado canales como malos, raw.info['bads'] tendrá contenido.
    # Necesitamos resetear la Referencia Average para que no busque los canales que acabas de matar.
    if raw.info['bads']:
        print(f"Detectados canales malos: {raw.info['bads']}")
        print("Reseteando matriz de referencia para evitar errores...")
        
        # A) Borrar referencia vieja (la de 62 canales)
        if raw.info['projs']: 
            raw.del_proj()
        
        # B) Crear referencia nueva (con los canales que quedan vivos)
        raw.set_eeg_reference('average', projection=True)
        raw.apply_proj()
        print("¡Referencia arreglada! ICA listo para ejecutarse.")

    # 4. ICA
    print("\n--- ICA (Calculando...) ---")
    # Filtramos copia para ICA (ignorando canales malos automáticamente)
    picks_ica = mne.pick_types(raw.info, eeg=True, exclude='bads')
    raw_for_ica = raw.copy().filter(l_freq=1.0, h_freq=None, n_jobs=1, verbose=False, picks=picks_ica)
    
    ica = mne.preprocessing.ICA(n_components=20, random_state=97)
    # reject_by_annotation=True hace que el ICA no aprenda del ruido que marcaste
    ica.fit(raw_for_ica, picks=picks_ica, decim=10, reject_by_annotation=True)
    
    print(">> SE ABRE VENTANA ICA: Marca Ojos/Corazón.")
    ica.plot_sources(raw_for_ica, block=True, title=f"ICA Run {i+1}")
    
    print("Aplicando limpieza...")
    raw = ica.apply(raw)
    del raw_for_ica

    # 5. EVENTOS
    events_raw, event_id_found = mne.events_from_annotations(raw, verbose=False)
    my_map = {}
    for desc in event_id_found:
        nums = re.findall(r'\d+', desc)
        if nums and int(nums[-1]) in TARGET_CODES:
            my_map[desc] = TARGET_CODES[int(nums[-1])]
    
    if not my_map: continue
    events, _ = mne.events_from_annotations(raw, event_id=my_map)

    # 6. EPOCHING
    print("--- Epoching ---")
    epochs = mne.Epochs(
        raw, events, event_id=None, tmin=-0.1, tmax=0.65, 
        baseline=(-0.1, 0), preload=True, reject=None, 
        reject_by_annotation=True, verbose=False
    )

    # 7. INTERPOLACIÓN FINAL (El toque maestro)
    # Ahora que ya hemos limpiado todo, recuperamos los canales malos interpolándolos.
    # Esto asegura que todos los runs tengan 62 canales al guardarse.
    if len(epochs.info['bads']) > 0:
        print(f"Interpolando canales malos antes de guardar: {epochs.info['bads']}")
        epochs.interpolate_bads(reset_bads=True, verbose=False)
    
    # 8. GUARDAR
    out_name = f_path.name.replace("_prepro_raw.fif", "_epo.fif")
    out_path = BASE_PATH / out_name
    print(f"Guardando: {out_name}")
    epochs.save(out_path, overwrite=True)
    
    del raw, epochs, ica

print("\n¡PROCESO COMPLETADO! Archivos listos y compatibles para concatenar.")
