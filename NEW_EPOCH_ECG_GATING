import mne
import numpy as np
import re
from pathlib import Path

# =============================================================================
# CONFIGURACIÓN ANÁLISIS COMPLEMENTARIO (Baseline -800ms + ECG Gating)
# =============================================================================
SUBJECT_DIR = Path("/home/marta.navarrobernad/Desktop/sub-P02/eeg")

# Parámetros de época (Criterio PI)
TMIN, TMAX = -0.850, 0.150  
BASELINE = (-0.800, 0.000) 
SUFFIX = "_BL800_COMPLEMENTARY"

# DICCIONARIO COMPLETO: 6 triggers por bloque (48 en total)
BLOCK_TRIGGERS = {
    # --- INATTENTIVE ---
    1: {"Std1": 161, "Std2": 164, "Std3_LS_GS": 165, "Dev1": 185, "Dev2": 188, "Dev3_LD_GD": 125},
    2: {"Std1": 169, "Std2": 172, "Std3_LD_GS": 109, "Dev1": 177, "Dev2": 180, "Dev3_LS_GD": 181},
    3: {"Std1": 105, "Std2": 108, "Std3_LD_GS": 173, "Dev1": 113, "Dev2": 116, "Dev3_LS_GD": 117},
    4: {"Std1": 97,  "Std2": 100, "Std3_LS_GS": 101, "Dev1": 121, "Dev2": 124, "Dev3_LD_GD": 189},
    # --- ATTENTIVE ---
    5: {"Std1": 73,  "Std2": 76,  "Std3_LD_GS": 141, "Dev1": 81,  "Dev2": 84,  "Dev3_LS_GD": 85},
    6: {"Std1": 137, "Std2": 140, "Std3_LD_GS": 77,  "Dev1": 145, "Dev2": 148, "Dev3_LS_GD": 149},
    7: {"Std1": 129, "Std2": 132, "Std3_LS_GS": 133, "Dev1": 153, "Dev2": 156, "Dev3_LD_GD": 93},
    8: {"Std1": 65,  "Std2": 68,  "Std3_LS_GS": 69,  "Dev1": 89,  "Dev2": 92,  "Dev3_LD_GD": 157}
}

def run_step3_final():
    # Buscamos archivos que tengan 'Ref' pero NO sean épocas ya creadas
    all_fifs = list(SUBJECT_DIR.glob("*Ref*.fif"))
    input_files = sorted([
        f for f in all_fifs 
        if "-epo.fif" not in f.name and SUFFIX not in f.name
    ])
    
    print(f"--- INICIANDO GATING + EPOCHING COMPLETO (48 TRIGGERS) ---")
    
    if not input_files:
        print("ERROR: No se encontraron archivos de entrada válidos.")
        return

    for f_path in input_files:
        match = re.search(r'Run(\d+).*Ref(\w+)', f_path.name)
        if not match: 
            continue
            
        run_idx = int(match.group(1))
        ref_type = match.group(2)
        
        if run_idx not in BLOCK_TRIGGERS:
            continue
            
        target_dict = BLOCK_TRIGGERS[run_idx]
        print(f"\n>> Procesando Run {run_idx} | Ref: {ref_type}")

        try:
            # 1. CARGA
            raw = mne.io.read_raw_fif(f_path, preload=True, verbose=False)
            events, _ = mne.events_from_annotations(raw, verbose=False)
            
            # Filtramos solo los triggers definidos para este bloque
            current_id = {k: v for k, v in target_dict.items() if v in events[:, 2]}
            
            if not current_id:
                print(f"   Aviso: No se encontraron triggers en {f_path.name}")
                continue

            # 2. EPOCHING
            epochs = mne.Epochs(raw, events, event_id=current_id, 
                                tmin=TMIN, tmax=TMAX, baseline=BASELINE, 
                                preload=True, verbose=False)
            
            n_initial = len(epochs)

            # 3. ECG GATING (Lógica de set prohibido +/- 150ms)
            if 'ECG' in raw.ch_names:
                ecg_result = mne.preprocessing.find_ecg_events(raw, ch_name='ECG', verbose=False)
                ecg_events = ecg_result[0]
                
                sr = raw.info['sfreq']
                win_samps = int(0.150 * sr)
                
                bad_samples = set()
                for r_peak in ecg_events[:, 0]:
                    bad_samples.update(range(r_peak - win_samps, r_peak + win_samps))
                
                # Identificar épocas a eliminar
                epochs_to_drop = [i for i, smp in enumerate(epochs.events[:, 0]) if smp in bad_samples]
                
                if epochs_to_drop:
                    pct = (len(epochs_to_drop) / n_initial) * 100
                    print(f"   -> ECG Gating: Eliminando {len(epochs_to_drop)} épocas ({pct:.2f}%)")
                    epochs.drop(epochs_to_drop, reason='ECG_coincidence', verbose=False)
                else:
                    print("   -> ECG Gating: 0 épocas eliminadas.")

            # 4. GUARDADO
            out_name = f"Clean_Epochs_Run{run_idx}_Ref{ref_type}{SUFFIX}-epo.fif"
            epochs.save(SUBJECT_DIR / out_name, overwrite=True, verbose=False)
            
            n_final = len(epochs)
            total_loss = ((n_initial - n_final) / n_initial) * 100
            print(f"   -> Finalizado: {n_final}/{n_initial} épocas guardadas ({total_loss:.1f}% drop total)")

        except Exception as e:
            print(f"   !!! ERROR en Run {run_idx}: {e}")

    print("\n--- PROCESO COMPLETADO ---")

if __name__ == "__main__":
    run_step3_final()
