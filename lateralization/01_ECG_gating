#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Mar  2 11:16:27 2026

@author: marta.navarrobernad
"""

import mne
import numpy as np
import re
from pathlib import Path

# =============================================================================
# CONFIGURACIÓN ANÁLISIS DE LATERALIZACIÓN (Right vs Left)
# =============================================================================
SUBJECT_DIR = Path("/home/marta.navarrobernad/Desktop/sub-P02/eeg")

# Mantenemos parámetros de SSEP (ajustar si prefieres los de PI)
TMIN, TMAX = -0.020, 0.080  
BASELINE = (-0.020, -0.005) 
SUFFIX = "_LATERALIZATION"

# DICCIONARIO REORGANIZADO POR LADO DE ESTIMULACIÓN
BLOCK_TRIGGERS = {
    # --- INATTENTIVE ---
    1: {"Stim/Right": [161, 164, 165, 185, 188], "Stim/Left": [125]},
    2: {"Stim/Right": [169, 172, 177, 180, 181], "Stim/Left": [109]},
    3: {"Stim/Right": [173], "Stim/Left": [105, 108, 113, 116, 117]},
    4: {"Stim/Right": [189], "Stim/Left": [97, 100, 101, 121, 124]},
    # --- ATTENTIVE ---
    5: {"Stim/Right": [141], "Stim/Left": [73, 76, 81, 84, 85]},
    6: {"Stim/Right": [137, 140, 145, 148, 149], "Stim/Left": [77]},
    7: {"Stim/Right": [129, 132, 133, 153, 156], "Stim/Left": [93]},
    8: {"Stim/Right": [157], "Stim/Left": [65, 68, 69, 89, 92]}
}

def run_lateralization_analysis():
# Buscamos archivos de referencia TH6 o AC, pero EXCLUIMOS los bipolares Pol
    all_fifs = list(SUBJECT_DIR.glob("*Ref*.fif"))
    input_files = sorted([
        f for f in all_fifs 
        if "-epo.fif" not in f.name 
        and SUFFIX not in f.name
        and "Pol" not in f.name
    ])
    
    print(f"--- INICIANDO ANÁLISIS DE LATERALIZACIÓN (RIGHT vs LEFT) ---")
    
    if not input_files:
        print("ERROR: No se encontraron archivos de entrada válidos.")
        return

    for f_path in input_files:
        match = re.search(r'Run(\d+).*Ref(\w+)', f_path.name)
        if not match: continue
            
        run_idx = int(match.group(1))
        ref_type = match.group(2)
        
        if run_idx not in BLOCK_TRIGGERS: continue
            
        mapping = BLOCK_TRIGGERS[run_idx]
        print(f"\n>> Procesando Run {run_idx} | Ref: {ref_type}")

        try:
            # 1. CARGA
            raw = mne.io.read_raw_fif(f_path, preload=True, verbose=False)
            events, _ = mne.events_from_annotations(raw, verbose=False)
            
            # 2. RE-ETIQUETADO DE EVENTOS
            # Creamos un nuevo array de eventos donde los códigos se unifican por lado
            new_events = []
            event_id = {"Stim/Right": 1, "Stim/Left": 2}
            
            for ev in events:
                code = ev[2]
                if code in mapping["Stim/Right"]:
                    new_events.append([ev[0], 0, 1])
                elif code in mapping["Stim/Left"]:
                    new_events.append([ev[0], 0, 2])
            
            new_events = np.array(new_events)
            
            if len(new_events) == 0:
                print(f"   Aviso: No se encontraron triggers de lateralización en {f_path.name}")
                continue

            # 3. EPOCHING
            epochs = mne.Epochs(raw, new_events, event_id=event_id, 
                                tmin=TMIN, tmax=TMAX, baseline=BASELINE, 
                                preload=True, verbose=False)
            
            n_initial = len(epochs)

            # 4. ECG GATING (Usando el canal 'ECG')
            if 'ECG' in raw.ch_names:
                ecg_result = mne.preprocessing.find_ecg_events(raw, ch_name='ECG', verbose=False)
                ecg_events = ecg_result[0]
                sr = raw.info['sfreq']
                win_samps = int(0.150 * sr)
                
                bad_samples = set()
                for r_peak in ecg_events[:, 0]:
                    bad_samples.update(range(r_peak - win_samps, r_peak + win_samps))
                
                epochs_to_drop = [i for i, smp in enumerate(epochs.events[:, 0]) if smp in bad_samples]
                
                if epochs_to_drop:
                    epochs.drop(epochs_to_drop, reason='ECG_coincidence', verbose=False)
                    print(f"   -> ECG Gating: Eliminadas {len(epochs_to_drop)} épocas")

            # 5. GUARDADO
            out_name = f"Lat_Epochs_Run{run_idx}_Ref{ref_type}{SUFFIX}-epo.fif"
            epochs.save(SUBJECT_DIR / out_name, overwrite=True, verbose=False)
            
            print(f"   -> Finalizado: {len(epochs)} épocas guardadas (R: {len(epochs['Stim/Right'])}, L: {len(epochs['Stim/Left'])})")

        except Exception as e:
            print(f"   !!! ERROR en Run {run_idx}: {e}")

    print("\n--- PROCESO DE LATERALIZACIÓN COMPLETADO ---")

if __name__ == "__main__":
    run_lateralization_analysis()
