import mne
import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path
import re 

# =============================================================================
# 1. CONFIGURACIÓN
# =============================================================================
BASE_PATH = Path(r"C:\Users\navar\Desktop\sub-P01\sub-P01")
INPUT_RAW = BASE_PATH / "sub-P01_preprocessed_raw.fif"
OUTPUT_EPO = BASE_PATH / "sub-P01_MMN_P3b_Stable_epo.fif"

# Escalas para visualización final
VIZ_SCALINGS = dict(eeg=50e-6, eog=50e-6, misc=50e-6)

# Canales EEG (Cerebro - Para calcular el ICA)
EEG_CHS = [
    'Fp1', 'Fz', 'F3', 'F7', 'FT9', 'FC5', 'FC1', 'C3', 'T7', 'TP9', 'CP5', 'CP1', 
    'Pz', 'P3', 'P7', 'O1', 'Oz', 'O2', 'P4', 'P8', 'TP10', 'CP6', 'CP2', 'C4', 
    'T8', 'FT10', 'FC6', 'FC2', 'F4', 'F8', 'Fp2', 'AF7', 'AF3', 'AFz', 'F1', 
    'F5', 'FT7', 'FC3', 'C1', 'C5', 'TP7', 'CP3', 'P1', 'P5', 'PO7', 'PO3', 
    'POz', 'PO4', 'PO8', 'P6', 'P2', 'CPz', 'CP4', 'TP8', 'C6', 'C2', 'FC4', 
    'FT8', 'F6', 'AF8', 'AF4', 'F2'
]

# =============================================================================
# 2. CARGA DE DATOS
# =============================================================================
print(f"Cargando archivo: {INPUT_RAW.name}...")
raw = mne.io.read_raw_fif(INPUT_RAW, preload=True)

# =============================================================================
# 3. ICA (Optimizado con High-Pass 1Hz)
# =============================================================================
print("\n--- PREPARANDO ICA ---")
print("Creando copia filtrada a 1.0Hz para que el ICA detecte bien los ojos...")

# 1. Hacemos una COPIA para calcular
raw_for_ica = raw.copy()

# 2. Filtramos la copia a 1.0 Hz (CRÍTICO para quitar el warning y mejorar la detección)
# Esto hace que los parpadeos se vean súper nítidos para el algoritmo
raw_for_ica.filter(l_freq=1.0, h_freq=None, n_jobs=1, verbose=False)

print("Calculando componentes ICA (decim=10)...")
ica = mne.preprocessing.ICA(n_components=20, random_state=97)

# 3. Ajustamos (fit) usando la copia filtrada
ica.fit(raw_for_ica, picks=EEG_CHS, decim=10)

print("--- SELECCIÓN DE COMPONENTES ---")
print("Ahora verás los componentes mucho más claros.")
print("1. Busca el 'Latido' (Ojo vertical): Montaña gigante al principio.")
print("2. Márcalo en ROJO (clic en el nombre).")

# 4. Visualizamos
# Nota: Al plotear sources, verás la señal limpia de la copia.
ica.plot_sources(raw_for_ica, block=True, start=0, stop=30, title="ICA: Marca Ojos (Basado en 1Hz)")

# 5. APLICAMOS AL ORIGINAL
# Aquí está la magia: Calculamos en la filtrada, pero limpiamos la ORIGINAL (raw)
print("Aplicando limpieza a los datos originales (sin filtrar a 1Hz)...")
raw = ica.apply(raw)

# Borramos la copia para liberar memoria
del raw_for_ica
# =============================================================================
# 4. GESTIÓN DE EVENTOS Y LIMPIEZA ECG (Gating)
# =============================================================================
print("\nAnalizando eventos...")
events_raw, event_id_found = mne.events_from_annotations(raw, verbose=False)

# Mapeo de códigos
target_codes = {
    # Left
    18: 111, 19: 112, 20: 113, 21: 114, 22: 115, 23: 116, 25: 121,
    # Right
    34: 211, 35: 212, 36: 213, 37: 214, 38: 215, 39: 216, 41: 221
}

# Búsqueda robusta de números
my_map = {}
for description in event_id_found.keys():
    numbers = re.findall(r'\d+', description)
    if numbers:
        code_in_file = int(numbers[-1])
        if code_in_file in target_codes:
            my_map[description] = target_codes[code_in_file]

if not my_map:
    print("¡ERROR CRÍTICO! No se encontraron eventos compatibles.")
else:
    events, _ = mne.events_from_annotations(raw, event_id=my_map)
    print(f"Total eventos encontrados: {len(events)}")

# --- LIMPIEZA DE ÉPOCAS POR ECG ---
if 'ECG' in raw.ch_names:
    print("\n--- GATING ECG (Protección de señal Espinal) ---")
    try:
        # CORRECCIÓN AQUÍ: Usamos [0] para coger solo los eventos,
        # ignorando si la función devuelve 3 o 4 valores extra.
        ecg_events = mne.preprocessing.find_ecg_events(raw, ch_name='ECG', verbose=False)[0]
        
        # Definir zona prohibida (+/- 150ms)
        sr = raw.info['sfreq']
        bad_samples = set()
        # Convertimos 150ms a muestras
        win_samps = int(0.150 * sr)
        
        for r_peak in ecg_events[:, 0]:
            # Range es exclusivo al final, así que aseguramos cobertura
            bad_samples.update(range(r_peak - win_samps, r_peak + win_samps))
        
        # Filtrar eventos
        events_clean = [ev for ev in events if ev[0] not in bad_samples]
        
        n_removed = len(events) - len(events_clean)
        print(f"Eventos ELIMINADOS por latido cardiaco: {n_removed}")
        print(f"Eventos RESTANTES: {len(events_clean)}")
        
        events = np.array(events_clean)
    except Exception as e:
        print(f"Fallo en Gating ECG: {e}")
        # Importante: Si falla, imprimimos el error pero no detenemos el script
else:
    print("ADVERTENCIA: No hay canal ECG. No se puede hacer Gating.")
# =============================================================================
# 5. EPOCHING (ISI CORREGIDO)
# =============================================================================
print("\nCreando épocas (-0.1 a 0.65s)...")

# reject_by_annotation=False porque no hemos creado anotaciones manuales 'BAD'
epochs = mne.Epochs(
    raw, events, event_id=None, 
    tmin=-0.1, 
    tmax=0.65,  # 0.65s para respetar ISI de 0.7s
    baseline=(-0.1, 0), 
    preload=True, 
    reject=None, 
    reject_by_annotation=False 
)

# =============================================================================
# 6. RECHAZO MANUAL DE ÉPOCAS (FINAL)
# =============================================================================
print("\n--- RECHAZO MANUAL DE ÉPOCAS ---")
print("Se abrirá el visualizador. Marca las épocas ruidosas en ROJO.")
print("Aquí podrás ver si queda algún artefacto que el ICA no quitó.")

epochs.plot(
    block=True, 
    n_epochs=4, 
    n_channels=30, 
    scalings=VIZ_SCALINGS, 
    title="Rechazo Manual Final"
)

print(f"Épocas finales guardadas: {len(epochs)}")

# =============================================================================
# 7. GUARDADO
# =============================================================================
print(f"Guardando en: {OUTPUT_EPO}")
epochs.save(OUTPUT_EPO, overwrite=True)
print("¡PROCESO COMPLETADO CON ÉXITO!")
