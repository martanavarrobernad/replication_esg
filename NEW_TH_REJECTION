import mne
import numpy as np
from pathlib import Path
import gc
import os

# =============================================================================
# LIMPIEZA POR BLOQUES CON GUARDADO DIRECTO AL DISCO (ANTI-BORRADO)
# =============================================================================
BASE_DIR = Path("/home/marta.navarrobernad/Desktop/sub-P02/eeg")
INPUT_FILE = BASE_DIR / "All_Runs_Combined_RefTH6_BL800_COMPLEMENTARY-epo.fif"
# Carpeta temporal para los trozos
TEMP_DIR = BASE_DIR / "TEMP_CHUNKS"
OUT_DIR = BASE_DIR / "CLEAN_EPOCHS_FINAL"

TEMP_DIR.mkdir(exist_ok=True, parents=True)
OUT_DIR.mkdir(exist_ok=True, parents=True)

CH_ESG_BASE = ['Iz', 'SC1', 'SC6', 'S3', 'S4', 'S5', 'S6', 'S7', 'S8', 'S9', 
               'S11', 'S12', 'S13', 'S14', 'S15', 'S16', 'S17', 'S18', 'S19']
CH_ERB = ['ENG_ERB']
CH_AXI = ['ENG_AXILLA']

def get_thr(epochs, ch_type, minimum):
    try:
        data = epochs.get_data(picks=ch_type)
        if data.size == 0: return minimum
        p2ps = (np.max(data, axis=2) - np.min(data, axis=2)).max(axis=1) * 1e6
        return max(np.percentile(p2ps, 98), minimum)
    except:
        return minimum

def survival_cleaning_with_autosave():
    if not INPUT_FILE.exists():
        print("Archivo no encontrado.")
        return

    epochs_raw = mne.read_epochs(INPUT_FILE, preload=False, verbose=False)
    total_epochs = len(epochs_raw)
    chunk_size = 400 # Bajamos un poco más para asegurar
    
    chunk_files = []

    print(f"[+] Iniciando limpieza con auto-guardado ({total_epochs} épocas)...")

    for i, start in enumerate(range(0, total_epochs, chunk_size)):
        stop = min(start + chunk_size, total_epochs)
        print(f" >> Procesando y GUARDANDO bloque {i+1}: {start} a {stop}...")
        
        chunk = epochs_raw[start:stop].load_data()
        
        # Filtro Nierula Std
        chunk.filter(30, 400, method='iir', 
                     iir_params=dict(order=4, ftype='butter'), 
                     phase='zero', verbose=False)

        # Configuración de tipos (Tu lógica original)
        mapping = {ch: 'misc' for ch in chunk.ch_names}
        chunk.set_channel_types(mapping, verbose=False)
        new_types = {ch: 'eeg' for ch in CH_ESG_BASE if ch in chunk.ch_names}
        if CH_ERB[0] in chunk.ch_names: new_types[CH_ERB[0]] = 'emg'
        if CH_AXI[0] in chunk.ch_names: new_types[CH_AXI[0]] = 'eog'
        chunk.set_channel_types(new_types, verbose=False)

        # Umbrales y Limpieza
        t_esg = get_thr(chunk, 'eeg', 100)
        t_erb = get_thr(chunk, 'emg', 250)
        t_axi = get_thr(chunk, 'eog', 400)
        chunk.drop_bad(reject={'eeg': t_esg*1e-6, 'emg': t_erb*1e-6, 'eog': t_axi*1e-6}, verbose=False)
        
        # GUARDADO TEMPORAL INMEDIATO (Si se peta Spyder, esto sobrevive)
        chunk_path = TEMP_DIR / f"chunk_{i}_clean-epo.fif"
        chunk.save(chunk_path, overwrite=True, verbose=False)
        chunk_files.append(chunk_path)
        
        del chunk
        gc.collect()

    print("\n[+] Todos los bloques limpios se han guardado en disco.")
    print("[+] Intentando unión final...")

    # Ahora unimos los archivos que están en el disco, no en la RAM
    try:
        all_chunks = [mne.read_epochs(f, preload=True, verbose=False) for f in chunk_files]
        final_epochs = mne.concatenate_epochs(all_chunks)
        out_path = OUT_DIR / "Final_Clean_Giant_Epochs-epo.fif"
        final_epochs.save(out_path, overwrite=True, verbose=True)
        print(f" >> ÉXITO: Archivo final guardado en {out_path.name}")
        
        # Limpiar temporales si todo salió bien
        for f in chunk_files: os.remove(f)
        
    except Exception as e:
        print(f" !! El ordenador no pudo unir los trozos al final, pero los tienes guardados en: {TEMP_DIR}")
        print(f" Error: {e}")

if __name__ == "__main__":
    survival_cleaning_with_autosave()
