# -*- coding: utf-8 -*-
"""
Created on Thu Jan  8 15:48:48 2026

@author: navar
"""

# -*- coding: utf-8 -*-
"""
Sugerir threshold de rechazo EEG (reject={'eeg': ...}) a partir de tus epochs,
sin terminal ni argumentos.

- Lee FIFs por run y ref (refTH6/refAC)
- Extrae eventos automáticamente: Stimulus/S xx (BrainVision)
- Epoching SIN reject
- Calcula pico max abs por epoch (EEG)
- Sugiere threshold como percentil (P95 por defecto)
- Guarda CSV y muestra un TRESH_DICT listo para hardcodear
"""

from pathlib import Path
import re
import numpy as np
import pandas as pd
import mne

# =============================================================================
# CONFIG (EDITA AQUÍ)
# =============================================================================
RAW_ROOT = Path(r"C:\Users\navar\Desktop\sub-P01\sub-P01")
PARTICIPANT = "sub-P01"
RUNS = range(1, 7)
REF_VARIANTS = ["refTH6", "refAC"]

# Percentil recomendado: 95 (más estricto), 97, 99 (más permisivo)
PERCENTILE = 95

# Ventanas de epoch (como tu pipeline)
TMIN, TMAX = -0.1, 0.2
BASELINE = (-0.100, -0.001)

# Selección automática de eventos BrainVision:
# Esto captura "Stimulus/S 17", "Stimulus/S 21", etc.
STIM_PATTERN = r"Stimulus/S\s*\d+"

# Tus canales EEG
EEGCHANNELS = [
    "Fp1","Fz","F3","F7","FT9","FC5","FC1","C3","T7","TP9",
    "CP5","CP1","Pz","P3","P7","O1","Oz","O2","P4","P8",
    "TP10","CP6","CP2","C4","T8","FT10","FC6","FC2","F4","F8",
    "Fp2","AF7","AF3","AFz","F1","F5","FT7","FC3","C1","C5",
    "TP7","CP3","P1","P5","PO7","PO3","POz","PO4","PO8","P6",
    "P2","CPz","CP4","TP8","C6","C2","FC4","FT8","F6","AF8",
    "AF4","F2"
]

OUT_CSV = RAW_ROOT / f"{PARTICIPANT}_suggested_thresholds_P{PERCENTILE}_Stimulus.csv"


# =============================================================================
# HELPERS
# =============================================================================
def build_events_from_annotations_stim(raw, stim_regexp=STIM_PATTERN):
    """
    Extrae eventos desde annotations filtrando por regexp (Stimulus/S xx).
    Devuelve (events, event_id_filtrado).
    """
    events, event_id = mne.events_from_annotations(raw, regexp=stim_regexp, verbose=False)
    # Filtramos event_id por las keys que matcheen (por si acaso)
    rx = re.compile(stim_regexp)
    event_id_f = {k: v for k, v in event_id.items() if rx.match(str(k))}
    return events, event_id_f


def suggest_threshold_from_epochs(epochs, percentile=95):
    """
    Devuelve threshold sugerido (V) y picos por epoch (V).
    threshold = percentil del max(abs(EEG)) por epoch.
    """
    data = epochs.get_data(picks="eeg")  # (n_epochs, n_ch, n_times)
    if data.size == 0:
        raise RuntimeError("No EEG data found in epochs.")
    peak_v = np.max(np.abs(data), axis=(1, 2))  # max abs por epoch (V)
    thr_v = float(np.percentile(peak_v, percentile))
    return thr_v, peak_v


# =============================================================================
# MAIN
# =============================================================================
rows = []

print(f"Participant: {PARTICIPANT}")
print(f"RAW_ROOT: {RAW_ROOT}")
print(f"Percentile: P{PERCENTILE}")
print(f"Stimulus regexp: {STIM_PATTERN}")
print("-" * 70)

for run in RUNS:
    for ref in REF_VARIANTS:
        in_f = RAW_ROOT / f"{PARTICIPANT}_Run{run}_eeg_{ref}.fif"
        if not in_f.exists():
            print(f"SKIP (missing): {in_f.name}")
            continue

        print(f"\nLoading: {in_f.name}")
        raw = mne.io.read_raw_fif(in_f, preload=True, verbose=False)

        eeg_ch = [ch for ch in EEGCHANNELS if ch in raw.ch_names]
        if not eeg_ch:
            print("  ⚠ No EEG channels found matching your EEGCHANNELS list.")
            continue

        events2, event_id_f = build_events_from_annotations_stim(raw, STIM_PATTERN)
        if len(events2) == 0 or not event_id_f:
            # si falla, imprime unas keys reales para diagnosticar
            _, event_id_all = mne.events_from_annotations(raw, verbose=False)
            print("  ⚠ No matching Stimulus events found with regexp.")
            print("  Available annotation keys (sample):", sorted(event_id_all.keys())[:30])
            continue

        # Epochs SIN reject
        epochs = mne.Epochs(
            raw,
            events2,
            event_id=event_id_f,
            tmin=TMIN,
            tmax=TMAX,
            baseline=BASELINE,
            detrend=1,
            preload=True,
            picks=eeg_ch,
            reject=None,
            verbose=False
        )

        thr_v, peak_v = suggest_threshold_from_epochs(epochs, percentile=PERCENTILE)
        peak_uv = peak_v * 1e6

        p90 = float(np.percentile(peak_uv, 90))
        p95 = float(np.percentile(peak_uv, 95))
        p97 = float(np.percentile(peak_uv, 97))
        p99 = float(np.percentile(peak_uv, 99))
        thr_uv = thr_v * 1e6

        print(f"  events used: {len(events2)}  | epochs: {len(epochs)}")
        print(f"  peak max abs (µV): P90={p90:.1f}, P95={p95:.1f}, P97={p97:.1f}, P99={p99:.1f}")
        print(f"  >>> suggested threshold: {thr_uv:.1f} µV  ({thr_v:.3e} V)")

        rows.append({
            "subject": PARTICIPANT,
            "run": run,
            "ref": ref,
            "n_events": int(len(events2)),
            "n_epochs": int(len(epochs)),
            "percentile": float(PERCENTILE),
            "suggested_threshold_uV": float(thr_uv),
            "suggested_threshold_V": float(thr_v),
            "P90_uV": p90,
            "P95_uV": p95,
            "P97_uV": p97,
            "P99_uV": p99,
            "file": str(in_f),
            "stimulus_keys": ";".join(sorted(event_id_f.keys()))
        })

if not rows:
    raise RuntimeError("No results produced (no files / no events / no EEG channels).")

df = pd.DataFrame(rows).sort_values(["run", "ref"])
df.to_csv(OUT_CSV, index=False, encoding="utf-8")
print("\nSaved CSV:", OUT_CSV)

# Sugerencia para hardcodear un único valor por sujeto (mediana de run/ref)
med_v = float(np.median(df["suggested_threshold_V"].values))
print("\nCopia y pega esto en tu pipeline:")
print("TRESH_DICT = {")
print(f'    "{PARTICIPANT}": {med_v:.3e},  # ~{med_v*1e6:.1f} µV (mediana run/ref, P{PERCENTILE})')
print("}")
