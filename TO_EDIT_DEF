
#!/usr/bin/env python3
"""
Preprocessing pipeline for spinal and EEG data.

This script prepares subject-specific configurations, defines EEG/spinal channel maps,
sets up a montage, and includes a function to temporally realign (stretch) EEG/Spinal
data based on specific evoked potentials (N9, N20, N25 components).
"""
import mne
from pathlib import Path
import numpy as np

PARTICIPANTS = ["sub-P01"]

# Your path
RAWPATH = Path(r"C:\Users\navar\Desktop\sub-P01\sub-P01")
PREFIX = "MULTICONS_2025-12-16_"

N_RUNS = 6  # HARD CODED

for participant in PARTICIPANTS:
    print(f"\nProcessing participant: {participant}")

    for run in range(1, N_RUNS + 1):
        fif_file = RAWPATH / f"{participant}_Run{run}_eeg.fif"
        if not fif_file.exists():
            raise FileNotFoundError(f"Missing file: {fif_file}")

        print(f"  → Run {run}: {fif_file.name}")

        # Load fif data (EEG + spinal in the same file)
        raw = mne.io.read_raw_fif(fif_file, preload=True, verbose=False)

        # If your pipeline expects a separate raw for EEG processing:
        raw2 = raw.copy()
        
# Channel definitions
EEGCHANNELS = [
    "Fp1","Fz","F3","F7","FT9","FC5","FC1","C3","T7","TP9",
    "CP5","CP1","Pz","P3","P7","O1","Oz","O2","P4","P8",
    "TP10","CP6","CP2","C4","T8","FT10","FC6","FC2","F4","F8",
    "Fp2","AF7","AF3","AFz","F1","F5","FT7","FC3","C1","C5",
    "TP7","CP3","P1","P5","PO7","PO3","POz","PO4","PO8","P6",
    "P2","CPz","CP4","TP8","C6","C2","FC4","FT8","F6","AF8",
    "AF4","F2"
]
#no se que hacer con erb
SPINALCHANNELS = [
    "Iz","SC1","SC6","S3","S4","S5","S6","S7","S8","S9",
    "S11","S12","S13","S14","S15","S16","S17","S18","S19",
    "AC","TH6","ENG_ERB_REF","ENG_ERB"
]

# =============================================================================
# Participant-specific settings
# =============================================================================

# Bad EEG channels, inspected with: bad_channels code
BADCHANNELS_EEG = {
    "sub-P01": [
        "AF7"
    ],
    #add more subjects if necessary
}

BADCHANNELS_SPINAL = {
    "sub-P01": [
    ],
}

TRESH_DICT = {
    "sub-P01": 1.5e-4,  # Calculated with: calculate_th_rejection 
}

#Baseline and artifact windows (in seconds)
BASELINE = (-0.100, -0.001)
STIMARTIFACT = (-0.001, 0.005)
    
# =============================================================================
# Event mapping with explicit stimulus positions
# =============================================================================
# Coding scheme:
#   Left  standards:  111–116  (position 1–6)
#   Left  deviant:    121
#   Right standards: 211–216  (position 1–6)
#   Right deviant:   221
#
# This preserves full positional information and can be grouped later if needed.
# =============================================================================

EVENT_DICT = {
    # -------------------------------------------------------------------------
    # LEFT — STANDARD (by position)
    # -------------------------------------------------------------------------
    "Stimulus/S 18": 111,  # Left, Standard, position 1
    "Stimulus/S 19": 112,  # Left, Standard, position 2
    "Stimulus/S 20": 113,  # Left, Standard, position 3
    "Stimulus/S 21": 114,  # Left, Standard, position 4
    "Stimulus/S 22": 115,  # Left, Standard, position 5
    "Stimulus/S 23": 116,  # Left, Standard, position 6

    # -------------------------------------------------------------------------
    # LEFT — DEVIANT
    # -------------------------------------------------------------------------
    "Stimulus/S 25": 121,  # Left, Deviant

    # -------------------------------------------------------------------------
    # RIGHT — STANDARD (by position)
    # -------------------------------------------------------------------------
    "Stimulus/S 34": 211,  # Right, Standard, position 1
    "Stimulus/S 35": 212,  # Right, Standard, position 2
    "Stimulus/S 36": 213,  # Right, Standard, position 3
    "Stimulus/S 37": 214,  # Right, Standard, position 4
    "Stimulus/S 38": 215,  # Right, Standard, position 5
    "Stimulus/S 39": 216,  # Right, Standard, position 6

    # -------------------------------------------------------------------------
    # RIGHT — DEVIANT
    # -------------------------------------------------------------------------
    "Stimulus/S 41": 221,  # Right, Deviant
}

# NOTE:
# - "Stimulus/S 17" is intentionally NOT included (ignored stimulus)

# =============================================================================
# EEG (actiCAP / easycap GmbH, 64ch 10–10) + SPINAL montage (hardcoded)
# =============================================================================

# -------------------------------------------------------------------------
# 1) SPINAL montage hardcoded (your geometry)
# Units: meters. x: left(-)/right(+). y: cranial(less negative)/caudal(more negative).
# -------------------------------------------------------------------------
spinal_ch_pos = {
    # EEG tail / junction
    "Iz":  [ 0.000, -0.105, 0.000],
    "SC1": [ 0.000, -0.1125, 0.000],  # midway between Iz (-0.105) and S3 (-0.120)

    # MIDLINE (x = 0.0) — 2 cm spacing
    "S3":  [ 0.000, -0.120, 0.000],
    "S6":  [ 0.000, -0.140, 0.000],
    "SC6": [ 0.000, -0.160, 0.000],
    "S14": [ 0.000, -0.180, 0.000],
    "S18": [ 0.000, -0.200, 0.000],

    # NEAR LATERALS (±1 cm), starting between S3 and S6 (1 cm below S3)
    # Right
    "S7":  [ 0.010, -0.130, 0.000],
    "S11": [ 0.010, -0.150, 0.000],
    "S15": [ 0.010, -0.170, 0.000],
    "S19": [ 0.010, -0.190, 0.000],
    # Left
    "S5":  [-0.010, -0.130, 0.000],
    "S9":  [-0.010, -0.150, 0.000],
    "S13": [-0.010, -0.170, 0.000],
    "S17": [-0.010, -0.190, 0.000],

    # FAR LATERALS (±5 cm), same height as S6 and S14
    "S4":  [-0.050, -0.140, 0.000],  # 5 cm left of S6
    "S8":  [ 0.050, -0.140, 0.000],  # 5 cm right of S6
    "S12": [-0.050, -0.180, 0.000],  # 5 cm left of S14
    "S16": [ 0.050, -0.180, 0.000],  # 5 cm right of S14

    # VERY LATERAL spinal electrodes (equivalent to EXG3/EXG6 in original)
    "ENG_ERB": [-0.090, -0.190, 0.000],  # left
    "ENG_ERB_REF": [ 0.090, -0.190, 0.000],  # right

    # References / auxiliary (visual placement based on your description)
    # AC: ventral, above S8 (right), and 1 cm above the height of S3
    "AC":  [ 0.050, -0.110, 0.000],
    # TH6: midline, 10 cm below S18
    "TH6": [ 0.000, -0.300, 0.000],
}

# Fix the position for visualization purposes (as in original: shift down by 1 cm)
for ch in list(spinal_ch_pos.keys()):
    spinal_ch_pos[ch] = [spinal_ch_pos[ch][0], spinal_ch_pos[ch][1] - 0.01, spinal_ch_pos[ch][2]]

# -------------------------------------------------------------------------
# 2) EEG montage (actiCAP 64ch, 10–10)
# -------------------------------------------------------------------------
eeg_montage = mne.channels.make_standard_montage("easycap-M1")
eeg_ch_pos = eeg_montage.get_positions()["ch_pos"].copy()

# -------------------------------------------------------------------------
# 3) Merge EEG + spinal into one montage and apply to raw
# -------------------------------------------------------------------------
# Overwrite/add spinal positions into EEG positions
eeg_ch_pos.update(spinal_ch_pos)

FULL_MONTAGE = mne.channels.make_dig_montage(ch_pos=eeg_ch_pos, coord_frame="head")

# =============================================================================
# Channel mapping for left/right mirroring (EEG + spinal, adapted to your setup)
# =============================================================================

MAPPING = {
    # ---------------------------------------------------------------------
    # EEG (10–10 system)
    # ---------------------------------------------------------------------
    "Fp2": "Fp1", "Fp1": "Fp2",
    "AF4": "AF3", "AF3": "AF4",
    "F8":  "F7",  "F7":  "F8",
    "F4":  "F3",  "F3":  "F4",
    "FC6": "FC5", "FC5": "FC6",
    "FC2": "FC1", "FC1": "FC2",
    "T8":  "T7",  "T7":  "T8",
    "C4":  "C3",  "C3":  "C4",
    "CP6": "CP5", "CP5": "CP6",
    "CP2": "CP1", "CP1": "CP2",
    "P8":  "P7",  "P7":  "P8",
    "P4":  "P3",  "P3":  "P4",
    "PO4": "PO3", "PO3": "PO4",
    "O2":  "O1",  "O1":  "O2",

    # Midline EEG (identity)
    "Fz": "Fz",
    "Pz": "Pz",
    "Oz": "Oz",

    # ---------------------------------------------------------------------
    # SPINAL — near laterals (±1 cm)
    # ---------------------------------------------------------------------
    "S5":  "S7",  "S7":  "S5",
    "S9":  "S11", "S11": "S9",
    "S13": "S15", "S15": "S13",
    "S17": "S19", "S19": "S17",

    # ---------------------------------------------------------------------
    # SPINAL — far laterals (±5 cm)
    # ---------------------------------------------------------------------
    "S4":  "S8",  "S8":  "S4",
    "S12": "S16", "S16": "S12",

    # ---------------------------------------------------------------------
    # SPINAL — extreme laterals
    # ---------------------------------------------------------------------
    "ENG_ERB": "ENG_ERB_REF", "ENG_ERB_REF": "ENG_ERB",

    # ---------------------------------------------------------------------
    # SPINAL midline / non-symmetric (identity)
    # ---------------------------------------------------------------------
    "Iz":  "Iz",
    "SC1": "SC1",
    "S3":  "S3",
    "S6":  "S6",
    "SC6": "SC6",
    "S14": "S14",
    "S18": "S18",
    "TH6": "TH6",

    # AC intentionally NOT mirrored (ventral, unilateral)
}

# =============================================================================
# Data alignment function
# =============================================================================
def stretcher(data):
    """
    Realign and stretch evoked EEG/spinal data around specific peaks (N9, N20, N25).

    The function identifies characteristic latencies (N9 spinal, N20/N25 cortical),
    shifts them to their expected positions, and then reconstructs a composite evoked
    response by merging and time-warping EEG and spinal channels.

    Parameters
    ----------
    data : mne.Epochs
        The epochs object containing both EEG and spinal channels.

    Returns
    -------
    newdata : mne.Evoked
        An evoked object with EEG and spinal signals realigned and temporally corrected.
    """

        # Compute average (Evoked) across epochs
    evoked = data.average()
    times = evoked.times
    sr = 5000.0
    
    # --- MMN correction (EEG) ---
    xmin_mmn, xmax_mmn = np.argwhere(times > 0.120).ravel()[0], np.argwhere(times > 0.220).ravel()[0]
    
    po3 = evoked.get_data()[evoked.info['ch_names'].index('PO3')]
    x_mmn = np.argmin(po3[xmin_mmn:xmax_mmn]) + xmin_mmn   # MMN negative peak
    real_mmn = np.abs(times - 0.170).argmin()              # expected MMN latency
    shift_mmn = (real_mmn - x_mmn) * (1 / sr)
    
    # --- P3 correction (EEG) ---
    xmin_p3, xmax_p3 = np.argwhere(times > 0.250).ravel()[0], np.argwhere(times > 0.450).ravel()[0]
    
    x_p3 = np.argmax(po3[xmin_p3:xmax_p3]) + xmin_p3       # P3 positive peak
    real_p3 = np.abs(times - 0.300).argmin()               # expected P3 latency
    shift_p3 = (real_p3 - x_p3) * (1 / sr)
    
    # Shift EEG channels (exclude spinal)
    mmn_corrected = evoked.copy().shift_time(shift_mmn, relative=True).drop_channels(SPINALCHANNELS)
    p3_corrected  = evoked.copy().shift_time(shift_p3,  relative=True).drop_channels(SPINALCHANNELS)
    
    # --- N9 correction (Spinal) ---
    xmin9, xmax9 = np.argwhere(times > 0.009).ravel()[0], np.argwhere(times > 0.013).ravel()[0]
    erberb = (
        evoked.get_data()[data.info['ch_names'].index('ENG_ERB_REF')]
        - evoked.get_data()[data.info['ch_names'].index('ENG_ERB')]
    )
    x9 = np.argmin(erberb[xmin9:xmax9]) + xmin9
    real9 = np.abs(times - 0.009).argmin()
    shift9 = (real9 - x9) * (1 / sr)
    
    n9corrected = evoked.copy().drop_channels(EEGCHANNELS)
    n9corrected.shift_time(shift9)
    
    # --- Align all signals to a common time window ---
    tmin = max([x.times[0] for x in [mmn_corrected, p3_corrected, n9corrected]])
    tmax = min([x.times[-1] for x in [mmn_corrected, p3_corrected, n9corrected]])
    
    mmn_corrected.crop(tmin, tmax)
    p3_corrected.crop(tmin, tmax)
    n9corrected.crop(tmin, tmax)
    
    # --- Merge EEG signals (MMN -> P3) ---
    times = mmn_corrected.times
    real_mmn = np.abs(times - 0.170).argmin()
    real_p3  = np.abs(times - 0.300).argmin()
    
    # Data before and after interpolation window
    data_mmn = mmn_corrected.get_data()[:, :real_mmn + 1]
    data_p3  = p3_corrected.get_data()[:, real_p3:]
    
    # Interpolate between MMN and P3
    d1, d2 = np.array(mmn_corrected.get_data()[:, real_mmn + 1:real_p3]).shape
    weights = np.array([
        [np.linspace(1, 0, d2)] * d1,
        [np.linspace(0, 1, d2)] * d1
    ])
    
    datamix = np.average(
        [mmn_corrected.get_data()[:, real_mmn + 1:real_p3],
         p3_corrected.get_data()[:,  real_mmn + 1:real_p3]],
        axis=0, weights=weights
    )
    
    # (si luego haces el merge final)
    newdata = np.concatenate([data_mmn, datamix, data_p3], axis=1)

    # Add spinal data back
    newdataspinal = n9corrected.get_data()
    newdata = np.concatenate([newdataspinal, newdata])

    # Build final MNE Evoked object
    newdata = mne.EvokedArray(newdata, evoked.info, tmin=times[0])

    return newdata

# =============================================================================
# MAIN PREPROCESSING LOOP
# =============================================================================
# Loop through each participant ID provided via command-line argument. 
# Using a single participant allows for  concurrent execution in parallel.
for participant in PARTICIPANTS:
    
    # Skip participants missing the reference channel 'S64' (used for spinal rereferencing)
    if 'TH6' not in BADCHANNELS_SPINAL[participant]:
        
        # ---------------------------------------------------------------------
        # SPINAL DATA PREPROCESSING
        # ---------------------------------------------------------------------
        
        # Load participant's raw data (contains both EEG and spinal)
        raw = mne.io.read_raw_fif(fif_file, preload=True, verbose=False)
        sr = 5000.0
        
        # Mark bad spinal channels for this participant
        raw.info['bads'].extend(BADCHANNELS_SPINAL[participant])
        
        # Extract the indexes of spinal channels from the raw data
        spinalindexes = [raw.info['ch_names'].index(x) for x in SPINALCHANNELS]
        
        # Set the spinal rereference to TH6 (the most caudal electrode)
        raw = raw.set_eeg_reference(ref_channels=['TH6'])
        
        # --- EVENT DETECTION ---
        # Extract trigger events (stimulus markers)
        events, event_id = mne.events_from_annotations(raw)

        inv = {v: k for k, v in event_id.items()}  # code -> description
        
        events_mapped = []
        for s, _, code in events:
            desc = inv.get(code)
            if desc in EVENT_DICT:
                events_mapped.append([s, 0, EVENT_DICT[desc]])
                
        events = np.array(events_mapped, dtype=int)       
        events_orig = np.array(events, dtype=int).copy()

        # --- INITIAL EPOCHING (spinal only, no baseline correction yet) ---
        epochs = mne.Epochs(
            raw, events, tmin=-0.1, tmax=0.700, detrend=0,
            baseline=None, proj=True, preload=True, picks=spinalindexes
        )
        
        evoked = epochs.average()  # Just for visualization if needed
        evoked.plot()
        
        # ---------------------------------------------------------------------
        # EVENT REFINEMENT BASED ON STIMULUS ARTIFACT
        # ---------------------------------------------------------------------
        # Precisely align events by detecting small deflections around 0 ms (solves USB triggering jitter)
        
        events = []  # reset list for refined events
        times = epochs.times  # time base matching epochs
        xmin, xmax = np.argwhere(times > -0.003).ravel()[0], np.argwhere(times > 0.003).ravel()[0]
        
        for i in range(len(epochs)):
            y = epochs[i].get_data()[0][0]  # get signal for first spinal channel
            treshold = max(abs(np.diff(y[:xmin]))) * 1.5  # dynamic threshold for artifact detection
            
            # Skip epochs that are too flat (likely bad)
            if max(abs(y[:xmin])) < 0.005:
                try:
                    # Find first large derivative (stim onset)
                    x = np.where((abs(np.diff(y[xmin:xmax])) > treshold) == True)[0][0] + xmin
                    
                    # Recenter event timing to detected peak
                    zero = np.abs(times).argmin()
                    event = epochs[i].events[0]
                    event[0] += x - zero  # adjust event latency
                    events.append(event)
                except:
                    # If no artifact is found, skip
                    pass
        
        # ---------------------------------------------------------------------
        # SPINAL DATA CLEANING & FILTERING
        # ---------------------------------------------------------------------
        
        # Remove residual stimulation artifact by linear interpolation
        events = np.array(events, dtype=int)
        if events.size == 0:
            print("⚠ No refined events found; falling back to original events for fix_stim_artifact.")
            events = events_orig

        mne.preprocessing.fix_stim_artifact(
            raw, events=events,
            tmin=STIMARTIFACT[0], tmax=STIMARTIFACT[1],
            mode='linear'
        )
        
        # Band-pass filter spinal channels (50–800 Hz typical for spinal potentials)
        raw.filter(50, 800, n_jobs=-1)
        
        # Recreate epochs with detrending, baseline, and artifact rejection
        epochs = mne.Epochs(
            raw, events, tmin=-0.1, tmax=0.700, detrend=1,
            baseline=BASELINE, proj=True, preload=True,
            picks=spinalindexes, reject={'eeg': TRESH_DICT[participant]}
        )
        
        data = epochs.get_data()  # Extract cleaned spinal data
        ids = epochs.selection     # Keep only good epoch indices
        eventsSelected = np.array(events)[ids]  # Filter events accordingly
        
        # ---------------------------------------------------------------------
        # EEG DATA PREPROCESSING
        # ---------------------------------------------------------------------
        
        # Reload raw data
        raw2 = raw = mne.io.read_raw_fif(fif_file, preload=True, verbose=False).load_data()
        sr = 5000.0
        
        # Mark bad EEG channels
        raw2.info['bads'].extend(BADCHANNELS_EEG[participant])
        
        # Extract EEG channel indices
        eegindexes = [raw2.info['ch_names'].index(x) for x in EEGCHANNELS]
        
        # Set EEG reference
        raw2 = raw2.set_eeg_reference(['TP10'])
        
        # Remove stimulation artifact from EEG as well
        mne.preprocessing.fix_stim_artifact(
            raw2, events=eventsSelected,
            tmin=STIMARTIFACT[0], tmax=STIMARTIFACT[1],
            mode='linear'
        )
        
        # Band-pass filter EEG channels (1–40 Hz)
        raw2.filter(1, 40, n_jobs=-1)
        
        # ======================================================
        # ICA for blink (EOG) removal -- EEG ONLY
        # ======================================================
        import mne
        
        # 1) Detect EOG channels (ajusta si tus nombres son otros)
        EOG_CHS = [ch for ch in ["VEOG", "HEOG", "EOG", "EXG1", "EXG2"] if ch in raw2.ch_names]
        
        # 2) Trabajar con una copia que tenga SOLO EEG (+EOG si existe)
        keep_chs = [ch for ch in EEGCHANNELS if ch in raw2.ch_names] + EOG_CHS
        raw2_ica_src = raw2.copy().pick_channels(keep_chs)
        
        # 3) Marcar EOG como tipo 'eog' (si existe)
        if len(EOG_CHS) > 0:
            raw2_ica_src.set_channel_types({ch: "eog" for ch in EOG_CHS})
            print("EOG channels used:", EOG_CHS)
        else:
            print("⚠ No EOG channels found; ICA blink removal may not work well.")
        
        # 4) Copia high-pass para entrenar ICA (mejor para artefactos)
        raw_ica = raw2_ica_src.copy().filter(l_freq=1.0, h_freq=None, n_jobs=1)
        
        ica = mne.preprocessing.ICA(
            n_components=0.999,      # <- sube esto (o usa un int, ver abajo)
            method="fastica",
            random_state=97,
            max_iter="auto"
        )
        
        # IMPORTANT: fit SOLO EEG por nombres (no uses picks="eeg" en tu caso)
        picks_eeg_names = [ch for ch in EEGCHANNELS if ch in raw_ica.ch_names]
        ica.fit(raw_ica, picks=picks_eeg_names)
        
        # 5) Detectar componentes EOG (si hay canal EOG)
        if len(EOG_CHS) > 0:
            eog_inds, eog_scores = ica.find_bads_eog(raw_ica, ch_name=EOG_CHS[0])
            ica.exclude = eog_inds
            print("ICA components removed (EOG):", eog_inds)
        
        # 6) Aplicar al raw2 ORIGINAL (pero SOLO afecta a los canales presentes en raw2_ica_src)
        raw2 = ica.apply(raw2)
        
        # Epoch EEG data around the same events
        epochs2 = mne.Epochs(
            raw2, eventsSelected, tmin=-0.1, tmax=0.700, detrend=1,
            baseline=BASELINE, proj=True, preload=False, picks=eegindexes, reject={'eeg': TRESH_DICT[participant]}
        )
        
        data2 = epochs2.get_data()

        # ---------------------------------------------------------------------
        # MATCH EPOCHS BETWEEN SPINAL + EEG (CHANGE B)
        # ---------------------------------------------------------------------
        # epochs   : spinal epochs (with rejection)
        # epochs2  : EEG epochs (with rejection)
        # eventsSelected : events corresponding to spinal-clean epochs

        # Indices of epochs kept after rejection
        ids_spinal = epochs.selection          # indices w.r.t. original spinal events
        ids_eeg = epochs2.selection             # indices w.r.t. eventsSelected

        # Build a mask over eventsSelected that keeps only EEG-surviving epochs
        keep_eeg_mask = np.zeros(len(eventsSelected), dtype=bool)
        keep_eeg_mask[ids_eeg] = True

        # Apply the same mask to spinal data
        data = data[keep_eeg_mask]

        # Rebuild EEG data in the full eventsSelected order
        data2_full = np.empty(
            (len(eventsSelected), data2.shape[1], data2.shape[2]),
            dtype=data2.dtype
        )
        data2_full[:] = np.nan
        data2_full[ids_eeg] = data2

        # Apply mask so EEG and spinal have identical epoch order
        data2 = data2_full[keep_eeg_mask]

        # Keep matching events only
        eventsSelected = eventsSelected[keep_eeg_mask]

        # Safety check
        if data.shape[0] != data2.shape[0]:
            raise RuntimeError(
                f"Epoch mismatch after intersection: spinal={data.shape[0]} EEG={data2.shape[0]}"
            )

        # ---------------------------------------------------------------------
        # COMBINE SPINAL + EEG INTO ONE DATA STRUCTURE
        # ---------------------------------------------------------------------
        data3 = np.hstack([data, data2])  # concatenate along channel axis
        info = mne.create_info(SPINALCHANNELS + EEGCHANNELS, sr, ch_types='eeg')

        combined = mne.EpochsArray(data3, info, eventsSelected, tmin=-0.1)
        
        data3 = np.hstack([data, data2])  # concatenate along channel axis
        info = mne.create_info(SPINALCHANNELS + EEGCHANNELS, sr, ch_types='eeg')
        
        combined = mne.EpochsArray(data3, info, eventsSelected, tmin=-0.1)
        combined.set_montage(FULL_MONTAGE, on_missing='ignore')
        
        # Propagate bad channels to the combined dataset (robust + no duplicates)
        combined.info['bads'].extend(BADCHANNELS_EEG.get(participant, []))
        combined.info['bads'].extend(BADCHANNELS_SPINAL.get(participant, []))
        combined.info['bads'] = sorted(
            {ch for ch in combined.info['bads'] if ch in combined.ch_names},
            key=combined.ch_names.index
        )
# %%
# ===== VISUALIZACIÓN SEPARADA EEG / ESG =====

# EEG channels (usa TU lista)
epochs_eeg = combined.copy().pick_channels(
    [ch for ch in EEGCHANNELS if ch in combined.ch_names]
)
evoked_eeg = epochs_eeg.average()

evoked_eeg.plot(
    spatial_colors=True,
    xlim=(-0.1, 0.6),
    titles="EEG ONLY"
)

# ESG / spinal channels (usa TU lista)
epochs_esg = combined.copy().pick_channels(
    [ch for ch in SPINALCHANNELS if ch in combined.ch_names]
)
evoked_esg = epochs_esg.average()

evoked_esg.plot(
    spatial_colors=True,
    xlim=(-0.05, 0.3),
    titles="ESG / SPINAL ONLY"
)

# %%
# %%
import mne
import numpy as np
import matplotlib.pyplot as plt

# -----------------------------
# 1) Definir ALL standards/deviants
# -----------------------------
ALL_STANDARDS = [111,112,113,114,115,116, 211,212,213,214,215,216]
ALL_DEVIANTS  = [121, 221]

epochs_std = combined[[str(x) for x in ALL_STANDARDS]]
epochs_dev = combined[[str(x) for x in ALL_DEVIANTS]]

# EEG only (por nombres)
epochs_std_eeg = epochs_std.copy().pick_channels([ch for ch in EEGCHANNELS if ch in combined.ch_names])
epochs_dev_eeg = epochs_dev.copy().pick_channels([ch for ch in EEGCHANNELS if ch in combined.ch_names])

print("N std epochs:", len(epochs_std_eeg))
print("N dev epochs:", len(epochs_dev_eeg))

# -----------------------------
# 2) (Opcional) Filtro ERP para VISUALIZACIÓN (NO toca tu pipeline)
#    0.1–30 Hz suele mejorar MMN/P3
# -----------------------------
epochs_std_eeg_f = epochs_std_eeg.copy().filter(l_freq=0.1, h_freq=30, n_jobs=-1)
epochs_dev_eeg_f = epochs_dev_eeg.copy().filter(l_freq=0.1, h_freq=30, n_jobs=-1)

# Baseline (por si acaso; si ya la tienes, no pasa nada)
epochs_std_eeg_f.apply_baseline((-0.1, -0.001))
epochs_dev_eeg_f.apply_baseline((-0.1, -0.001))

# Evoked + diferencia
ev_std  = epochs_std_eeg_f.average()
ev_dev  = epochs_dev_eeg_f.average()
ev_diff = mne.combine_evoked([ev_dev, ev_std], weights=[1, -1])  # DEV - STD

t = ev_std.times

# -----------------------------
# 3) Regiones (mejor SNR que single-channel)
# -----------------------------
MMN_CHS = ["Fz", "FCz", "Cz", "FC1", "FC2"]   # fronto-central (MMN)
P3_CHS  = ["Pz", "CPz", "POz", "P1", "P2"]    # parietal (P3)

MMN_CHS = [ch for ch in MMN_CHS if ch in ev_std.ch_names]
P3_CHS  = [ch for ch in P3_CHS  if ch in ev_std.ch_names]

print("MMN channels used:", MMN_CHS)
print("P3 channels used :", P3_CHS)

def region_mean(evoked, chs):
    return evoked.copy().pick(chs).data.mean(axis=0) * 1e6  # µV

# -----------------------------
# 4) Plot (negro/gris/rojo) + ventanas guía
# -----------------------------
MMN_WIN = (0.150, 0.250)
P3_WIN  = (0.280, 0.500)

def plot_region(title, chs, tmax):
    if not chs:
        print(f"⚠ No channels available for {title}")
        return

    y_std  = region_mean(ev_std,  chs)
    y_dev  = region_mean(ev_dev,  chs)
    y_diff = y_dev - y_std

    plt.figure()
    plt.plot(t, y_std,  color="black", linewidth=2, label="Standard")
    plt.plot(t, y_dev,  color="0.6",   linewidth=2, label="Deviant")     # gris
    plt.plot(t, y_diff, color="red",   linewidth=2, label="DEV - STD")   # rojo

    plt.axhline(0, color="black", linewidth=1)
    plt.axvspan(*MMN_WIN, color="0.9")
    plt.axvspan(*P3_WIN,  color="0.9")
    plt.xlim(-0.1, tmax)
    plt.xlabel("Time (s)")
    plt.ylabel("Amplitude (µV)")
    plt.title(title)
    plt.legend()
    plt.show()

plot_region("MMN region (fronto-central) — mean(Fz/FCz/Cz/...)", MMN_CHS, tmax=0.6)
plot_region("P3 region (parietal) — mean(Pz/CPz/POz/...)",       P3_CHS,  tmax=0.8)

# %%
import mne

# --- IDs: TODOS los standards vs TODOS los deviants ---
ALL_STANDARDS = [111,112,113,114,115,116, 211,212,213,214,215,216]
ALL_DEVIANTS  = [121, 221]

# --- Subset epochs ---
epochs_std = combined[[str(x) for x in ALL_STANDARDS]]
epochs_dev = combined[[str(x) for x in ALL_DEVIANTS]]

# --- EEG only (por nombres, no por tipo) ---
epochs_std_eeg = epochs_std.copy().pick_channels([ch for ch in EEGCHANNELS if ch in combined.ch_names])
epochs_dev_eeg = epochs_dev.copy().pick_channels([ch for ch in EEGCHANNELS if ch in combined.ch_names])

# --- Evoked ---
ev_std = epochs_std_eeg.average()
ev_dev = epochs_dev_eeg.average()
ev_diff = mne.combine_evoked([ev_dev, ev_std], weights=[1, -1])  # DEV - STD

# --- Plot butterflies ---
ev_std.plot(
    spatial_colors=True,
    xlim=(-0.1, 0.6),
    titles="EEG STANDARD (all)"
)

ev_dev.plot(
    spatial_colors=True,
    xlim=(-0.1, 0.6),
    titles="EEG DEVIANT (all)"
)

ev_diff.plot(
    spatial_colors=True,
    xlim=(-0.1, 0.6),
    titles="EEG DIFF (DEV - STD)"
)

# %%
# ========= EVENT GROUPS =========
LEFT_STANDARD_IDS  = [111, 112, 113, 114, 115, 116]
LEFT_DEVIANT_IDS   = [121]
RIGHT_STANDARD_IDS = [211, 212, 213, 214, 215, 216]
RIGHT_DEVIANT_IDS  = [221]

# TODOS los standards / todos los deviants
ALL_STANDARDS = LEFT_STANDARD_IDS + RIGHT_STANDARD_IDS
ALL_DEVIANTS  = LEFT_DEVIANT_IDS + RIGHT_DEVIANT_IDS

# ========= SUBSETS =========
epochs_std_all = combined[[str(x) for x in ALL_STANDARDS]]
epochs_dev_all = combined[[str(x) for x in ALL_DEVIANTS]]

print(f"standards: {len(epochs_std_all)} epochs")
print(f"deviants : {len(epochs_dev_all)} epochs")

# ========= EVOKEDS =========
ev_std_all = epochs_std_all.average()
ev_dev_all = epochs_dev_all.average()

# ========= SAVE =========
ev_std_all.save(
    RAWPATH / f"{participant}_standard-ave.fif",
    overwrite=True
)
ev_dev_all.save(
    RAWPATH / f"{participant}_deviant-ave.fif",
    overwrite=True
)

# ========= QUICK SANITY CHECK =========
ev_std_all.plot(picks="eeg", xlim=(-0.1, 0.6), titles="STANDARD (all)")
ev_dev_all.plot(picks="eeg", xlim=(-0.1, 0.6), titles="DEVIANT (all)")


# Build LEFT/RIGHT "hand" sets for alignment (equivalent to original 11/12 and 21/22)
epochsLeft  = combined[[str(x) for x in (LEFT_STANDARD_IDS + LEFT_DEVIANT_IDS)]].set_montage(FULL_MONTAGE, on_missing="ignore")
epochsRight = combined[[str(x) for x in (RIGHT_STANDARD_IDS + RIGHT_DEVIANT_IDS)]].set_montage(FULL_MONTAGE, on_missing="ignore")

# --- LEFT conditions (optional comparisons) ---
epochs_left_standard = combined[[str(x) for x in LEFT_STANDARD_IDS]].set_montage(FULL_MONTAGE, on_missing="ignore")
epochs_left_deviant  = combined[[str(x) for x in LEFT_DEVIANT_IDS]].set_montage(FULL_MONTAGE, on_missing="ignore")
# --- RIGHT conditions (optional comparisons) ---
epochs_right_standard = combined[[str(x) for x in RIGHT_STANDARD_IDS]].set_montage(FULL_MONTAGE, on_missing="ignore")
epochs_right_deviant  = combined[[str(x) for x in RIGHT_DEVIANT_IDS]].set_montage(FULL_MONTAGE, on_missing="ignore")

# --- GLOBAL (collapsing sides) ---
epochs_standard_all = combined[[str(x) for x in (LEFT_STANDARD_IDS + RIGHT_STANDARD_IDS)]].set_montage(FULL_MONTAGE, on_missing="ignore")
epochs_deviant_all  = combined[[str(x) for x in (LEFT_DEVIANT_IDS + RIGHT_DEVIANT_IDS)]].set_montage(FULL_MONTAGE, on_missing="ignore")

# (optional) Evoked objects for quick checking
ev_left_std  = epochs_left_standard.average()
ev_left_dev  = epochs_left_deviant.average()
ev_right_std = epochs_right_standard.average()
ev_right_dev = epochs_right_deviant.average()
ev_std_all   = epochs_standard_all.average()
ev_dev_all   = epochs_deviant_all.average()

ev_std_all.save(RAWPATH / f"{participant}_standard-ave.fif", overwrite=True)
ev_dev_all.save(RAWPATH / f"{participant}_deviant-ave.fif", overwrite=True)
combined.save(RAWPATH / f"{participant}_combined-epo.fif", overwrite=True)

# ---------------------------------------------------------------------
# Mirror RIGHT -> LEFT space using MAPPING (like original)
# (Do this for the "right-hand" set that will be aligned/combined)
# ---------------------------------------------------------------------
bads = [MAPPING.get(ch, ch) for ch in epochsRight.info.get('bads', [])]
epochsRight = epochsRight.rename_channels(MAPPING)
epochsRight.info['bads'] = bads
epochsRight.set_montage(FULL_MONTAGE, on_missing="ignore")

# ---------------------------------------------------------------------
# ALIGN AND STRETCH EEG/SPINAL DATA USING N9/N20/N25 CORRECTION
# ---------------------------------------------------------------------
# NOTE: your stretcher() returns only an Evoked (not (evoked, epochs)).
# We therefore align and save Evoked objects here (same idea as original).

newevokeds = []
for source in [epochsLeft, epochsRight]:
    evoked = stretcher(source)
    newevokeds.append(evoked)

# Determine overlapping time windows for both hands
tmins = [x.times[0] for x in newevokeds]
tmaxs = [x.times[-1] for x in newevokeds]

for evoked in newevokeds:
    evoked.crop(max(tmins), min(tmaxs))

# Save aligned evokeds (one per side)
hand = ['left', 'right']
for i, evoked in enumerate(newevokeds):
    evoked.save(
        (RAWPATH / f"{participant}_{hand[i]}-ave.fif"),
        overwrite=True
    )

# -------------------------------------------------------------------------
# If reference channel 'TH6' is missing, skip this participant
# -------------------------------------------------------------------------
else:
   PARTICIPANTS.pop(PARTICIPANTS.index(participant))
# %%
# -*- coding: utf-8 -*-
"""
Sanity check / inspection of combined EEG+spinal EpochsArray
EEG-only visualization
"""

import mne
import numpy as np
import matplotlib.pyplot as plt

# =============================
# 1) CHECK BASIC INFO
# =============================
print(combined)
print("\nSampling rate:", combined.info["sfreq"])
print("Time range   :", combined.tmin, "to", combined.tmax)
print("Bad channels :", combined.info["bads"])

# =============================
# 2) EEG-ONLY VIEW (INTERACTIVE)
# =============================
# Keep only EEG channels
epochs_eeg = combined.copy().pick("eeg")

print("\nEEG channels:", len(epochs_eeg.ch_names))
print("First 20 EEG channels:", epochs_eeg.ch_names[:20])

# Interactive epoch browser
epochs_eeg.plot(
    n_epochs=10,
    n_channels=20,
    scalings="auto",
    block=True
)
